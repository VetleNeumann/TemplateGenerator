using LightLexer;
using LightLexer.Helpers;
using LightParser;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Buffers;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Data;
using System.Data.SqlTypes;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Xml.Linq;
using static System.Net.Mime.MediaTypeNames;

namespace TemplateGenerator
{
	static class DiagnosticDescriptors
	{
		public static readonly DiagnosticDescriptor TemplateFailed = new("TGEN001", "Template failed to render", "Template '{0}' failed with error: {1}", "Renderer", DiagnosticSeverity.Error, true);

		public static readonly DiagnosticDescriptor FilterFailed = new("TGEN002", "Template filter failed", "Generator '{0}' filter failed at '{1}' with: {2}, {3}", "Filter", DiagnosticSeverity.Error, true);

		public static readonly DiagnosticDescriptor CreateModelFailed = new("TGEN003", "Template create model failed", "Generator '{0}' create model failed with: {1}, {2}", "CreateModel", DiagnosticSeverity.Error, true);

		public static readonly DiagnosticDescriptor CreateModelReportedNoDiagnostics = new("TGEN004", "Template create model failed", "Generator '{0}' failed without giving any diagnostics", "CreateModel", DiagnosticSeverity.Error, true);
	}

	public record struct DataOrDiagnostic<T>
	{
		public EquatableArray<Diagnostic> diagnostics;
		public bool hasData;
		public T data;

		public DataOrDiagnostic()
		{
			this.diagnostics = new();
		}

		public DataOrDiagnostic(T data)
		{
			this.diagnostics = new();
			this.hasData = true;
			this.data = data;
		}

		public DataOrDiagnostic(List<Diagnostic> diagnostic)
		{
			this.hasData = false;
			this.diagnostics = new(diagnostic.ToArray());
		}

		public static implicit operator DataOrDiagnostic<T>(T value)
		{
			return new DataOrDiagnostic<T>(value);
		}

		public static implicit operator DataOrDiagnostic<T>(Diagnostic value)
		{
			return new DataOrDiagnostic<T>(new List<Diagnostic>() { value });
		}
	}

	public record struct GeneratorOptions(LoggingOptions? loggingOptions);

	public record struct LoggingOptions(string filePath, LogLevel level, bool infoFile);

	public class TemplateGeneratorBuilder
	{
		internal ILogger logger;
		List<(LogLevel, string)> logCache = new();

		public TemplateGeneratorBuilder WithLogging(IncrementalGeneratorInitializationContext context)
		{
			var options = context.AnalyzerConfigOptionsProvider
				 .Select((options, _) =>
				 {
					 var loggingOptions = TemplateGeneratorHelpers.GetLoggingOptions(options);

					 return new GeneratorOptions(loggingOptions);
				 });

			var logging = options
					.Select((options, _) => options.loggingOptions)
					.Select((options, _) =>
					{
						logger = options is null
									 ? NullLogger.Instance
									 : new Logger(options.Value.level,
												  options.Value.filePath);

						logCache.ForEach(x => logger.Log(x.Item1, x.Item2));

						return 0;
					})
					.SelectMany((i, _) => ImmutableArray<int>.Empty);

			context.RegisterSourceOutput(logging, static (_, _) => { });
			return this;
		}

		public TemplateGeneratorBuilder WithInfoFile(IncrementalGeneratorInitializationContext context)
		{
			var options = context.AnalyzerConfigOptionsProvider
				 .Select((options, _) =>
				 {
					 var loggingOptions = TemplateGeneratorHelpers.GetLoggingOptions(options);

					 return new GeneratorOptions(loggingOptions);
				 });

			context.RegisterSourceOutput(options.Select((o, _) => o.loggingOptions), (context, o) =>
			{
				if (!o.HasValue || !o.Value.infoFile)
					return;

				var sb = new StringBuilder("//--- AutoGenerated info file. ---\n\n");
				sb.Append("//--- Log: ---\n\n");
				logger.GetMessages().ForEach(msg => sb.AppendLine($"// {msg.Replace(Environment.NewLine, $"{Environment.NewLine}//")}"));

				context.AddSource("TemplateGeneratorLog.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
			});
			return this;
		}

		public TemplateGeneratorBuilder WithGenerator<TNode, TData>(IncrementalGeneratorInitializationContext context, ITemplateSourceGenerator<TNode, TData> generator)
			where TNode : SyntaxNode
			where TData : struct, IEquatable<TData>, ITemplateData
		{
			try
			{
				TemplateGeneratorHelpers.RegisterTemplateGenerator(context, generator, new ListLogger(logCache), this);
			}
			catch (Exception e)
			{
				new ListLogger(logCache).Log(LogLevel.Error, e.StackTrace.Replace(Environment.NewLine, " "));
			}

			return this;
		}

		public TemplateGeneratorBuilder WithAttributeGenerator<TNode, TData>(string attribute, IncrementalGeneratorInitializationContext context, ITemplateSourceGenerator<TNode, TData> generator)
			where TNode : SyntaxNode
			where TData : struct, IEquatable<TData>, ITemplateData
		{
			try
			{
				TemplateGeneratorHelpers.RegisterAttributeTemplateGenerator(attribute, context, generator, new ListLogger(logCache), this);
			}
			catch (Exception e)
			{
				new ListLogger(logCache).Log(LogLevel.Error, e.StackTrace.Replace(Environment.NewLine, " "));
			}

			return this;
		}
	}

	public static class TemplateGeneratorHelpers
	{
		static Dictionary<EngineState, IState<NodeType, EngineState>> stateDict = new()
		{
			{ EngineState.TextState,  new TextState() },
			{ EngineState.Expression, new ExpressionState() },
			{ EngineState.Code,       new CodeState() },
			{ EngineState.Variable,   new VariableState() },
		};

		public static void RegisterTemplateGenerator<TNode, TData>(IncrementalGeneratorInitializationContext context, ITemplateSourceGenerator<TNode, TData> generator, ILogger logger, TemplateGeneratorBuilder builder)
			where TNode : SyntaxNode
			where TData : struct, IEquatable<TData>, ITemplateData
		{
			DataOrDiagnostic<TData>? Filter(GeneratorSyntaxContext x, CancellationToken cancellationToken)
			{
				try
				{
					DataOrDiagnostic<TData> result = new();
					result.hasData = generator.TryGetData(x.Node as TNode, x.SemanticModel, out result.data, out var diagnostics);
					//result.diagnostics = new(diagnostics.ToArray());

					if (result.hasData)
					{
						if (x.Node is BaseTypeDeclarationSyntax btd)
							builder.logger.Log(LogLevel.Trace, $"Generator '{generator.GetType().Name}' will be run on node at '{x.Node.GetLocation()}' ('{btd.Identifier}')");
						else
							builder.logger.Log(LogLevel.Trace, $"Generator '{generator.GetType().Name}' will be run on node at '{x.Node.GetLocation()}'");
					}

					return result;
				}
				catch (Exception e)
				{
					var diagnostic = Diagnostic.Create(DiagnosticDescriptors.FilterFailed, null, generator.GetType().Name, x.Node.ToFullString(), e.Message, e.StackTrace.Replace(Environment.NewLine, " "));

					builder.logger.Log(diagnostic);
					return diagnostic;
					//throw new Exception($"Generator '{generator.GetType().Name}' filter failed at '{x.Node.ToFullString()}' with: {e.Message}, {e.StackTrace.Replace(Environment.NewLine, " ")}");
				}
			}

			logger.Log(LogLevel.Trace, $"Registering generator '{generator.GetType().Name}'");
			var generatorNodes = context.SyntaxProvider
				.CreateSyntaxProvider(
					(x, _) => x is TNode t,
					Filter
				).Where(x => x is not null)
				.Where(x =>
				{
					//logger.LogCounter($"{generator.GetType().Name} ")
					return true;
				});

			var failedNodes = generatorNodes
				.Where(x => x?.diagnostics.Count > 0)
				.Select((x, _) => x?.diagnostics ?? new());

			var sucessfullNodes = generatorNodes
				.Where(x => x?.hasData ?? false)
				.Select((x, _) => x?.data);

			context.RegisterSourceOutput(failedNodes, OutputDiagnostic);
			context.RegisterSourceOutput(sucessfullNodes, (spc, data) => ExectureGeneratorNew(spc, data ?? default, generator, builder.logger)); // Data is filtered before so should not be null
		}

		public static void RegisterAttributeTemplateGenerator<TNode, TData>(string attribute, IncrementalGeneratorInitializationContext context, ITemplateSourceGenerator<TNode, TData> generator, ILogger logger, TemplateGeneratorBuilder builder)
			where TNode : SyntaxNode
			where TData : struct, IEquatable<TData>, ITemplateData
		{
			DataOrDiagnostic<TData>? Filter(GeneratorAttributeSyntaxContext x, CancellationToken cancellationToken)
			{
				try
				{
					DataOrDiagnostic<TData> result = new();
					result.hasData = generator.TryGetData(x.TargetNode as TNode, x.SemanticModel, out result.data, out var diagnostics);
					//result.diagnostics = new(diagnostics.ToArray());

					if (result.hasData)
					{
						if (x.TargetNode is BaseTypeDeclarationSyntax btd)
							builder.logger.Log(LogLevel.Trace, $"Generator '{generator.GetType().Name}' will be run on node at '{x.TargetNode.GetLocation()}' ('{btd.Identifier}')");
						else
							builder.logger.Log(LogLevel.Trace, $"Generator '{generator.GetType().Name}' will be run on node at '{x.TargetNode.GetLocation()}'");
					}

					return result;
				}
				catch (Exception e)
				{
					var diagnostic = Diagnostic.Create(DiagnosticDescriptors.FilterFailed, null, generator.GetType().Name, x.TargetNode.ToFullString(), e.Message, e.StackTrace.Replace(Environment.NewLine, " "));

					builder.logger.Log(diagnostic);
					return diagnostic;
					//throw new Exception($"Generator '{generator.GetType().Name}' filter failed at '{x.TargetNode.ToFullString()}' with:\n {e.Message},\n{e.StackTrace.Replace(Environment.NewLine, " ")}");
				}
			}

			logger.Log(LogLevel.Trace, $"Registering attribute generator '{generator.GetType().Name}'");
			var generatorNodes = context.SyntaxProvider
				.ForAttributeWithMetadataName(
					attribute,
					(x, _) => x is TNode t,
					Filter
				).Where(x => x is not null);

			var failedNodes = generatorNodes
				.Where(x => x?.diagnostics.Count > 0)
				.Select((x, _) => x?.diagnostics ?? new());

			var sucessfullNodes = generatorNodes
				.Where(x => x?.hasData ?? false)
				.Select((x, _) => x?.data);

			context.RegisterSourceOutput(failedNodes, OutputDiagnostic);
			context.RegisterSourceOutput(sucessfullNodes, (spc, data) => ExectureGeneratorNew(spc, data ?? default, generator, builder.logger)); // Data is filtered before so should not be null
		}

		public static LoggingOptions? GetLoggingOptions(AnalyzerConfigOptionsProvider options)
		{
			//return new("DemoSourceGenerator.log", LogLevel.Trace);

			if (!options.GlobalOptions.TryGetValue("build_property.TemplateGenerator_LogFilePath",
												   out var logFilePath))
				return null;

			if (String.IsNullOrWhiteSpace(logFilePath))
				return null;

			logFilePath = logFilePath.Trim();

			if (!options.GlobalOptions.TryGetValue("build_property.TemplateGenerator_LogLevel",
												   out var logLevelValue)
				|| !Enum.TryParse(logLevelValue, true, out LogLevel logLevel))
			{
				logLevel = LogLevel.Information;
			}

			bool infoFile = options.GlobalOptions.TryGetValue("build_property.TemplateGenerator_InfoFile", out var _);

			return new LoggingOptions(logFilePath, logLevel, infoFile);
		}

		static void OutputDiagnostic(SourceProductionContext context, EquatableArray<Diagnostic> diagnostics)
			=> diagnostics.ToList().ForEach(context.ReportDiagnostic);

		static void ExectureGeneratorNew<TNode, TData>(SourceProductionContext context, TData data, ITemplateSourceGenerator<TNode, TData> generator, ILogger logger)
			where TNode : SyntaxNode
			where TData : struct, IEquatable<TData>, ITemplateData
		{
			logger.Log(LogLevel.Trace, $"Executing generator '{data.GetIdentifier()}'");

			bool modelResult;
			List<Diagnostic> diagnostics;
			Model<ReturnType> model;

			try
			{
				modelResult = generator.TryCreateModel(data, out model, out diagnostics);
			}
			catch (Exception e)
			{
				context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.CreateModelFailed, generator.GetLocation(data), generator.GetName(data), e.Message, e.StackTrace.Replace(Environment.NewLine, " ")));
				logger.Log(LogLevel.Error, $"Generator crashed while creating model");
				return;
				//throw new Exception($"Generator '{generator.GetName(data)}' failed with:\n {e.StackTrace.Replace(Environment.NewLine, " ")}");
			}

			foreach (var diagnostic in diagnostics.GroupBy(x => (x.Id, x.Location)).Select(x => x.First()))
			{
				context.ReportDiagnostic(diagnostic);
				logger.Log(diagnostic);
			}

			if (!modelResult)
			{
				if (diagnostics.Count == 0)
				{
					context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.CreateModelReportedNoDiagnostics, generator.GetLocation(data), generator.GetName(data)));
				}

				logger.Log(LogLevel.Error, $"Generator failed to create model with {diagnostics.Count} diagnostics.");
				return;
			}

			try
			{
				ModelStack<ReturnType> stack = new ModelStack<ReturnType>();
				stack.Push(model);

				var template = generator.Template.AsSpan();
				var renderResult = TryRenderTemplate(template, stack, out string result);

				if (!renderResult.Ok)
				{
					var errorSb = new StringBuilder("\n");
					for (int i = 0; i < renderResult.Errors.Count; i++)
					{
						errorSb.Append($"\t{renderResult.Lines[i]}: {renderResult.Errors[i]}\n");
						logger.Log(LogLevel.Warning, $"\t{renderResult.Lines[i]}: {renderResult.Errors[i]}\n");
					}

					context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.TemplateFailed, generator.GetLocation(data), $"{generator.GetName(data)}.g.cs", errorSb.ToString()));
					logger.Log(LogLevel.Error, $"Generator failed to render template");
					return;
				}

				logger.Log(LogLevel.Trace, $"Generator finished");
				context.AddSource($"{generator.GetName(data)}.g.cs", SourceText.From(result, Encoding.UTF8));
			}
			catch (Exception e)
			{
				logger.Log(LogLevel.Error, $"Generator failed while rendering '{generator.GetName(data)}' failed with: '{e.Message}' at {e.StackTrace.Replace(Environment.NewLine, " ")}");

				return;
			}
		}

		static ComputeResult TryRenderTemplate(ReadOnlySpan<char> template, ModelStack<ReturnType> stack, out string result)
		{
			StringBuilder sb = new StringBuilder();

			TokenEnumerable tokens = new TemplateRules().GetEnumerable(template);

			Parser<NodeType, EngineState> parser = new(stateDict, tokens);
			TypeResolver<NodeType, ReturnType> resolver = new(TypeResolver.ResolveType);

			var nodeArr = ArrayPool<Node<NodeType>>.Shared.Rent(4096 * 4);
			var typeArr = ArrayPool<ReturnType>.Shared.Rent(4096 * 4);

			var ast = parser.GetAst(nodeArr.AsSpan());
			int start = ast.InsertNode(NodeType.Start);
			ast.SetRight(start);

			parser.CalculateAst(ref ast, EngineState.TextState);

			bool hasNoLoops = VeriyTree(ast.GetTree(), out int idx);

			if (!hasNoLoops)
			{
				ref Node<NodeType> node = ref ast.GetTree()[idx];
				var str = node.token.GetSpan(template).ToString();

				var pointers = FindAllPointers(idx, ast.GetTree());

				Console.WriteLine($"Idx: {node.token.range.Start}-{node.token.range.End}, '{str}'");
                Console.WriteLine("Template:");
				for (int i = 0; i < template.Length; i++)
				{
					if (IsWithin(node.token.range, i))
					{
						Console.BackgroundColor = ConsoleColor.Red;
					}

					for (int a = 0; a < pointers.Count; a++)
					{
						if (IsWithin(ast.GetTree()[pointers[a]].token.range, i))
							Console.BackgroundColor = ConsoleColor.DarkCyan;
					}

					Console.Write(template[i]);
					Console.BackgroundColor = ConsoleColor.Black;
				}

                throw new Exception("Abstract Syntax Tree contains loops");
			}

			var types = resolver.ResolveTypes(ast.GetRoot(), ast.GetTree(), typeArr);

			TemplateContext<NodeType, ReturnType> context = new()
			{
				txt = template,
				nodes = ast.GetTree(),
				returnTypes = types
			};

			var computeResult = TemplateLanguageRules.Compute(ref context, 0, sb, stack);
			result = sb.ToString();

			ArrayPool<Node<NodeType>>.Shared.Return(nodeArr);
			ArrayPool<ReturnType>.Shared.Return(typeArr);

			return computeResult;
		}

		static bool IsWithin(Range range, int idx)
		{
			return idx >= range.Start.Value && idx < range.End.Value;
		}

		static List<int> FindAllPointers(int idx, ReadOnlySpan<Node<NodeType>> nodes)
		{
			List<int> pointers = new List<int>();
			for (int i = 0; i < nodes.Length; i++)
			{
				ref readonly Node<NodeType> curr = ref nodes[i];

				if (curr.right == idx || curr.middle == idx || curr.left == idx)
					pointers.Add(i);
			}

			return pointers;
		}

		static bool VeriyTree(ReadOnlySpan<Node<NodeType>> nodes, out int idx)
		{
			using RefStack<int> visited = new RefStack<int>(nodes.Length);
			visited.Push(0);

			for (int i = 0; i < nodes.Length; i++)
			{
				ref readonly Node<NodeType> curr = ref nodes[i];

				if (curr.right != -1 && SpanContains(visited.AsSpan(), curr.right))
				{
					idx = curr.right;
					return false;
				}	

				if (curr.middle != -1 && SpanContains(visited.AsSpan(), curr.middle))
				{
					idx = i;
					return false;
				}

				if (curr.left != -1 && SpanContains(visited.AsSpan(), curr.left))
				{
					idx = i;
					return false;
				}

				if (curr.right != -1)
					visited.Push(curr.right);

				if (curr.middle != -1)
					visited.Push(curr.middle);

				if (curr.left != -1)
					visited.Push(curr.left);
			}

			idx = -1;
			return true;
		}

		static bool SpanContains(ReadOnlySpan<int> span, int value)
		{
			for (int i = 0; i < span.Length; i++)
			{
				if (span[i] == value)
					return true;
			}

			return false;
		}
	}
}
